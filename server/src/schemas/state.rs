// Generated by packetc v0.2.3 at Thu, 11 Feb 2021 18:03:33 +0000
#![allow(dead_code, non_camel_case_types, unused_imports, clippy::field_reassign_with_default)]
use std::convert::TryFrom;
#[derive(Clone, PartialEq, Debug, Default)]
pub struct State {
    pub id: u32,
    pub entities: Vec<Entity>,
}
#[derive(Clone, PartialEq, Debug, Default)]
pub struct Position {
    pub x: f32,
    pub y: f32,
}
#[derive(Clone, PartialEq, Debug, Default)]
pub struct Entity {
    pub uid: u32,
    pub pos: Option<Position>,
}
pub fn read(reader: &mut packet::reader::Reader, output: &mut State) -> Result<(), packet::Error> {
    output.id = reader.read_uint32()?;
    let output_entities_len = reader.read_uint32()? as usize;
    output.entities.reserve(output_entities_len);
    for _ in 0..output_entities_len {
        let mut output_entities_item = Entity::default();
        output_entities_item.uid = reader.read_uint32()?;
        if reader.read_uint8()? > 0 {
            let mut output_entities_item_pos = Position::default();
            output_entities_item_pos.x = reader.read_float()?;
            output_entities_item_pos.y = reader.read_float()?;
            output_entities_item.pos = Some(output_entities_item_pos);
        }
        output.entities.push(output_entities_item);
    }
    Ok(())
}
pub fn write(writer: &mut packet::writer::Writer, input: &State) {
    writer.write_uint32(input.id);
    writer.write_uint32(input.entities.len() as u32);
    for input_entities_item in input.entities.iter() {
        writer.write_uint32(input_entities_item.uid);
        match &input_entities_item.pos {
            None => writer.write_uint8(0u8),
            Some(input_entities_item_pos) => {
                writer.write_uint8(1u8);
                writer.write_float(input_entities_item_pos.x);
                writer.write_float(input_entities_item_pos.y);
            }
        }
    }
}
